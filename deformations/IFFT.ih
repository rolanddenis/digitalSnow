
///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


template <typename TImage>
inline
DGtal::IFFT<TImage>
::IFFT( const Image& anImage)
  : myImage( anImage )
{
}


template <typename TImage>
inline
DGtal::IFFT<TImage>::~IFFT()
{
}


template <typename TImage>
template< typename TOutputImage >
inline
void
DGtal::IFFT<TImage>::compute(TOutputImage& anImage)
{
  typedef typename TOutputImage::Value OutputValue; 
  ASSERT( myImage.extent() == anImage.extent() );

  //image size
  Vector v = myImage.extent();  
  int t[dimension];
  int n = 1; 
  for (int i = 0; i < dimension; ++i) 
    { //row-major order
      t[dimension-1-i] = v[i];
      n *= v[i];  
    }

  //using fftw library
  //input and output arrays
  //fftw_complex* spatial_repr;
  double* spatial_repr;
  fftw_complex* frequency_repr;
  
  //spatial_repr    = (fftw_complex*) fftw_malloc(sizeof(fftw_complex)*n);
  spatial_repr=(double*) fftw_malloc(sizeof(double)*n);
  frequency_repr  = (fftw_complex*) fftw_malloc(sizeof(fftw_complex)*n);

  //fill the arrays
  Domain d = myImage.domain();  
  typename Domain::ConstIterator it = d.begin(); 
  typename Domain::ConstIterator itEnd = d.end(); 
  for(unsigned int i=0; it != itEnd; ++it, ++i)
    {
      Value c = myImage(*it);
     
      if ( i%t[dimension-1] <= t[dimension-1]/2 )
      {
        const unsigned int ii = i%t[dimension-1] + (i/t[dimension-1])*(t[dimension-1]/2+1);
        frequency_repr[ii][0] = real(c); //real part
        frequency_repr[ii][1] = imag(c); //imaginary part
      }
    }

  //plan
  fftw_plan plan;
  //plan = fftw_plan_dft( dimension, t, frequency_repr, spatial_repr, FFTW_BACKWARD, FFTW_ESTIMATE ); 
  plan = fftw_plan_dft_c2r( dimension, t, frequency_repr, spatial_repr, FFTW_ESTIMATE ); 

  //computation
  fftw_execute(plan);

  //copy 
  it = d.begin();
  for(unsigned int i=0; (i < n); ++it, ++i)
    {
      //real part divided by n
      //double s = spatial_repr[i][0]/n; 
      double s = spatial_repr[i]/n; 
      anImage.setValue( *it, static_cast<OutputValue>(s) ); 
    }

  //end
  fftw_destroy_plan(plan);
  fftw_free(spatial_repr);
  fftw_free(frequency_repr);
}


template <typename TImage>
inline
void
DGtal::IFFT<TImage>::selfDisplay ( std::ostream & out ) const
{
  out << "[IFFT] on " << myImage;
  out << std::endl;
}

template <typename TImage>
inline
bool
DGtal::IFFT<TImage>::isValid() const
{
  return true;
}



//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/* GNU coding style */
/* vim: set ts=2 sw=2 expandtab cindent cinoptions=>4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1 : */

