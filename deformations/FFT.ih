
///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


template <typename TImage>
inline
DGtal::FFT<TImage>
::FFT( const Image& anImage)
: myImage( anImage )
{
}


template <typename TImage>
inline
DGtal::FFT<TImage>::~FFT()
{
}


template <typename TImage>
inline
void
DGtal::FFT<TImage>::compute(ComplexImage& anImage)
{
  ASSERT( myImage.extent() == anImage.extent() );

  //image size
  Vector v = myImage.extent();  
  int t[dimension]; 
  int n = 1; 
  for (int i = 0; i < dimension; ++i) 
    { //row-major order
      t[dimension-1-i] = v[i];
      n *= v[i];  
    }

  //using fftw library
  //input and output arrays
  //fftw_complex* spatial_repr;
  double* spatial_repr;
  
  fftw_complex* frequency_repr;
  
  //spatial_repr    = (fftw_complex*) fftw_malloc(sizeof(fftw_complex)*n);
  spatial_repr    = (double*) fftw_malloc(sizeof(double)*n);
  frequency_repr  = (fftw_complex*) fftw_malloc(sizeof(fftw_complex)*n);

  Domain d = myImage.domain();  
  typename Domain::ConstIterator it = d.begin(); 
  typename Domain::ConstIterator itEnd = d.end(); 
   for(unsigned int i=0; it != itEnd; ++it, ++i)
   {
      //spatial_repr[i][0] = (double) myImage(*it);
      //spatial_repr[i][1] = 0.0;
      spatial_repr[i] = (double) myImage(*it);
   }

  //plan
  fftw_plan plan;
  //plan = fftw_plan_dft( dimension, t, spatial_repr, frequency_repr, FFTW_FORWARD, FFTW_ESTIMATE ); 
  plan = fftw_plan_dft_r2c( dimension, t, spatial_repr, frequency_repr, FFTW_ESTIMATE ); 

  //computation
   fftw_execute(plan);

  //copy 
  it = d.begin();
  const auto it_end = d.end();
  for(unsigned int i=0; it != it_end; ++it, ++i)
  {
    if ( i%t[dimension-1] <= t[dimension-1]/2 )
      {
        const unsigned int ii = i%t[dimension-1] + (i/t[dimension-1])*(t[dimension-1]/2+1);
        Complex c(frequency_repr[ii][0], frequency_repr[ii][1]); 
        anImage.setValue( *it, c );
      } 
    else 
      {
        const unsigned int ii = (t[dimension-1]-1 - i%t[dimension-1]) + (i/t[dimension-1])*(t[dimension-1]/2+1);
        Complex c(frequency_repr[ii][0], -frequency_repr[ii][1]); 
        anImage.setValue( *it, c );
      }

    //if (i == n/2) i = 0;
  }

  //end
   fftw_destroy_plan(plan);
   fftw_free(spatial_repr);
   fftw_free(frequency_repr);
}


template <typename TImage>
inline
void
DGtal::FFT<TImage>::selfDisplay ( std::ostream & out ) const
{
  out << "[FFT] on " << myImage;
  out << std::endl;
}

template <typename TImage>
inline
bool
DGtal::FFT<TImage>::isValid() const
{
    return true;
}



//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/* GNU coding style */
/* vim: set ts=2 sw=2 expandtab cindent cinoptions=>4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1 : */

