/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file MultiPhaseField2.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 * @author Roland Denis (\c roland.denis@univ-smb.fr )
 * LAboratory of MAthematics - LAMA (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2015/04/28
 *
 * @brief Implementation of inline methods defined in MultiPhaseField2.h
 *
 * This file is part of the DGtal library.
 */

#include <vector>
#include <iostream>

#include <Eigen/SVD>

#include <DGtal/images/SimpleThresholdForegroundPredicate.h>
#include "InlineTrace.h"

//#include <omp.h>
#include "RealFFT.h"


//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::MultiPhaseField2(LabelImage& aI, typename TFieldImage::Value epsilon)
  : myLabelImage( aI ),
    myFields{ myLabelImage.domain(), TApproximation{1e-4} },
    myEpsilon{ epsilon }
{ 
 
  // Domain
  Domain domain = myFields.domain();

  // Retrieve labels
  std::set<Label> labels;
  for ( auto const& label : myLabelImage )
    labels.insert( label );

  // Store labels
  myLabels.insert(myLabels.end(), labels.cbegin(), labels.cend() );

  // For each label, build the corresponding phase field
  for ( std::size_t i = 1; i < myLabels.size(); ++i )
    {
      std::cerr << "Region of label " << myLabels[i] << std::endl; 

      /// new phase field
      FieldImage image(domain); 

      /// DT computation
      getSignedDistance( myLabels[i], image );

      // Profile computation
      Profile profile( myEpsilon );  //TODO get epsilon from myEvolver or even better its profile function
      std::transform(image.begin(), image.end(), myFields[i].begin(), profile);       
    }

  // Build the air field (#0)
  // NB : maybe better if we rescale all fields ?
  std::cerr << "Region of label 0" << std::endl; 
  for ( auto const& point : domain )
    {
      typename TFieldImage::Value sum = 0;
      for ( auto v : myFields(point) )  sum += v.second;
      myFields.setValue( point, 0, 1 - sum );
    }

  // Calculating initial volume
  trace.beginBlock("Initial volumes");
  myInitVolume.resize(myLabels.size(), 0);
  for ( auto const& point : domain )
    {
      for ( auto v = myFields(point) )
        myInitVolume[v.first] =+ v.second;
    }
  trace.endBlock();

  // Initialize FFTW <- has nothing to do here ... just for dev
  if ( fftw_init_threads() == 0 ) std::cout << "!!! Parallel FFTW initialization failed !!!" << std::endl;
  fftw_plan_with_nthreads( 32 );

}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::~MultiPhaseField2()
{ 
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
double
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::update(const double& aT)
{
  using std::size_t; 
  using Point = typename TFieldImage::Point;
  using real = typename TFieldImage::Value;

  Domain domain = myFields.domain();

  // Diffusion
  trace.beginBlock("Diffusion");
  using FFT  =  RealFFT<Domain, real>;
  for ( size_t i = 0; i < myLabels.size(); ++i )
    {
      itrace.beginBlock("Diffusion");

      itrace.beginStep("Read");
      //auto bb_field = myFields.getBBImage(i, Point::diagonal(10)); // Bounding box & periodicity ?!!!
      auto bb_field = myFields[i];

      FFT fft(bb_field.domain());
      auto spatial_data = fft.getSpatialStorage();

      // Copy
      size_t row_pos = fft.getSpatialExtent()[0];
      for ( auto val : bb_field )
        {
          *(spatial_data++) = val;
          if ( --row_pos == 0 )
            {
              spatial_data += fft.getPadding();
              row_pos = fft.getSpatialExtent()[0];
            }
        }
      
      // Forward transformation
      itrace.beginStep("fftw");
      fft.forwardFFT(FFTW_MEASURE);

      itrace.beginStep("Conv");
      auto const extent = fft.getSpatialExtent();
      auto freq_data = fft.getFreqStorage();
      for ( auto const& point : fft.getFreqDomain() )
        {

          double norm2 = 0;
          for ( size_t j = 0; j < TFieldImage::dimension; ++j)
            {
              double coord = static_cast<double>(point[j]) / extent[j];
              if ( coord >= 0.5 ) coord -= 1.;
              norm2 += coord*coord;
            }
          const double c = std::exp( -4*M_PI*M_PI*aT*norm2 );

          // New value

          auto const v = *reinterpret_cast<std::complex<real>*>(freq_data);
          *(freq_data++) = { c*std::real(v), c*std::imag(v) };
        }

      // Back in spatial space
      itrace.beginStep("ifftw");
      fft.backwardFFT(FFTW_MEASURE);

      // Store the result
      itrace.beginStep("Write");
      spatial_data = fft.getSpatialStorage();
      row_pos = fft.getSpatialExtent()[0];
      const size_t n = fft.getSpatialDomain().size();
      for ( auto it = bb_field.begin(), it_end = bb_field.end(); it != it_end; ++it )
        {
          *it = *(spatial_data++) / n;
          if ( --row_pos == 0 )
            {
              spatial_data += fft.getPadding();
              row_pos = fft.getSpatialExtent()[0];
            }
        }

      itrace.endBlock();
    }
  trace.endBlock();
  // End diffusion

  bool reaction1 = false;
  if (reaction1) {
  // Phase overlap
  trace.beginBlock("Phase overlap");
  TFieldImage phase_overlap(domain);
  for ( auto const& point : domain )
    {
      real sum = 0;
      for ( auto const& value : myFields(point) )
        sum += value.second;
      phase_overlap.setValue(point, 1 - sum);
    }
  trace.endBlock();
  // End phase overlap
  
  // Volume loss estimation
  // \warning : we suppose that labels in LabelledMap are consecutive.
  trace.beginBlock("Volume loss estimation");
  std::vector<real> num( myLabels.size(), 0 );
  std::vector<real> denum( myLabels.size(), 0 );
  for ( auto const& point : domain )
    {
      for ( auto value : myFields(point) )
        {
          const real u = value.second;
          num[value.first]   += u * (u - 1) * (2*u - 1);
          denum[value.first] += std::abs(u) * std::abs(1 - u);
        }
    }
  
  std::vector<real> volume_loss( num.size() );
  for ( size_t i = 0; i < volume_loss.size(); ++i )
    volume_loss[i] = num[i] / denum[i];

  trace.endBlock();
  // End volume loss estimation
  
  // Lagrangian multiplier
  trace.beginBlock("Lagrange multiplier");
  for ( auto const& point : domain )
    {
      real sum = 0;
      for ( auto value : myFields(point) )
        {
          const real u = value.second;
          //sum += u*(u-1) * ( (2*u-1) + volume_loss[value.first] );
          sum += u*(u-1) * (2*u-1) -  volume_loss[value.first] * std::abs(u) * std::abs(1-u);
        }
      phase_overlap.setValue(point, ( sum + phase_overlap(point) ) / myLabels.size() );
      //phase_overlap.setValue(point, ( sum + phase_overlap(point) ) / myFields(point).size() );
    }
  trace.endBlock();
  // End Lagrangian multiplier

  // Evolution - Method A
  trace.beginBlock("Evolution");
  const real dummy = aT / (myEpsilon * myEpsilon);
  for ( auto const& point : domain )
    {
      size_t id = myFields.linearized(point); // Hum ...

      for ( size_t i = 0; i < myLabels.size(); ++i )
        {
          const real u = myFields.getValueByIndex(id, i);
          const real p = (u == 0) ? 0 : u*(u-1) * ( (2*u-1) + volume_loss[i] );
          //const real p = (u == 0) ? 0 : ( u*(u-1) *(2*u-1) - volume_loss[i]*std::abs(u*(1-u)) );
          const real v = u - dummy * (p - phase_overlap(point));
          myFields.setValue(point, i, v, id);
        }
    }
  trace.endBlock();
  // End evolution - Method A
  } // end block

  // Reaction
  if (!reaction1)
    {
      itrace.beginBlock("Reaction");
      const real dummy = aT / (myEpsilon * myEpsilon);
      for ( auto const& point : domain )
        {
          const size_t id = myFields.linearized(point);
          // Need for a mutable iterator over values ...
          for ( size_t i = 0; i < myLabels.size(); ++i )
            {
              const real u = myFields.getValueByIndex(id, i);
              if ( u != 0 )
                {
                  myFields.setValue(point, i, u - dummy * u * (u-1) * (2*u-1), id);
                }
            }
        }
      itrace.endBlock();

      itrace.beginBlock("Lagrangian");
      auto phi = [](real u) { return u; };

      itrace.beginStep("linear_system");
      const size_t phase_cnt = myInitVolume.size();
      Eigen::MatrixXd M( phase_cnt );
      Eigen::VectorXd b( phase_cnt );
      M.fill(0);

      for ( size_t i = 0; i < phase_cnt; ++i )
        b(i) = myInitVolume[i];

      for ( auto const& point : domain )
        {
          auto const& values = myFields(point);
          
          real sum_u = 0;
          real sum_phiu = 0;
          for ( auto const v : values )
            {
              sum_u += values.second;
              sum_phiu += phi(values.second);
            }

          for ( size_t i = 0; i < phase_cnt; ++i )
            {
              const real ui = values[i];
              const real phi_ui = phi(ui);
              const real weighted_phiu = phi_ui / sum_phiu;

              M(i,i)  += std::abs( ui * (1-ui) );
              b(i)    += -ui + weighted_phiu * ( sum_ui - 1 );
              for ( size_t j = 0; j < phase_cnt; ++j )
                {
                  const real uj = values[j];
                  M(i,j) -= weighted_phiu * std::abs( uj * (1-uj) );
                }
            }
        }
      itrace.endStep();

      itrace.beginStep("svd");
      Eigen::JacobiSVD<Eigen::MatrixXd> svd(M, ComputeFullU | ComputeFullV);
      auto s = svd.singularValues();
      for ( size_t i = 0; i < phase_cnt-1; ++i )
        s[i] = 1 / s[i];
      M = svd.matrixU() * s.asDiagonal() * svd.matrixV().transpose();
      Eigen::VectorXd mu = M * b;
                  



            }
        }

    }


  
  /// update image of labels
  {
    trace.beginBlock("Updating Label");
    for ( auto const& point : domain )
      {
        Label max_label;
        real max_value = 0;
        for ( std::size_t i = 0; i < myLabels.size(); ++i )
          {
            real value = myFields.getValue(point, i);
            if (value >= max_value)
              {
                max_value = value;
                max_label = myLabels[i];
              }
          }

        myLabelImage.setValue( point, max_label );
      }
    trace.endBlock();
  }

  trace.beginBlock("Statistics");
  trace.info() << myFields.getInfos() << std::endl;
  trace.endBlock();

  return aT; 
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::selfDisplay ( std::ostream & out ) const
{
  out << "[MultiPhaseField2] ";
  out << myFields.size() << " regions "; 
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
bool
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::isValid() const
{
  return true;
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getSignedDistance(const Label& aLabel, FieldImage& aImage) const
{

  Domain d = Domain( myLabelImage.domain().lowerBound(), myLabelImage.domain().upperBound() );
  typename Domain::ConstIterator cIt = d.begin(); 
  typename Domain::ConstIterator cItBegin = d.begin(); 
  typename Domain::ConstIterator cItEnd = d.end(); 

  //temporary buffers
  typedef ImageContainerBySTLVector<Domain, DGtal::int32_t> Image; 
  Image copy1( d );
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    { 
      if ( myLabelImage( *cIt ) == aLabel )
	copy1.setValue( *cIt, 0 ); 
      else
	copy1.setValue( *cIt, 1 ); 
    }
  Image copy2( d );  
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    { 
      if ( myLabelImage( *cIt ) != aLabel )
	copy2.setValue( *cIt, 0 ); 
      else
	copy2.setValue( *cIt, 1 ); 
    }

  // Distance transformation
  // Old code was:
  //    typedef  DistanceTransformation<Image, 2> DT;
  //    DT dt;
  //    typename DT::OutputImage dtImage = dt.compute ( copy1 );
  //    typename DT::OutputImage rDtImage = dt.compute ( copy2 );
  // 
  // I suppose that 2 means L2Metric (with the correct Z#i-namespace in scope),
  //    and that 0 value is used as threshold for the predicate.
  typedef typename DGtal::functors::SimpleThresholdForegroundPredicate<Image> PointPredicate;
  typedef typename DGtal::DistanceTransformation<Space, PointPredicate, L2Metric> DT;
    
  PointPredicate copy1Predicate( copy1, 0 );
  PointPredicate copy2Predicate( copy2, 0 );

  DT  dtImage( copy1.domain(), copy1Predicate, l2Metric );
  DT rDtImage( copy2.domain(), copy2Predicate, l2Metric );
  
  //deduce the signed distance function 
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    { //for each domain point

      Point p( *cIt ); //point p
      double dist = 0; //signed distance
      if ( dtImage( p ) == 0 )
	{
	  if ( rDtImage( p ) == 0 )
	    ASSERT( false && "Err init with DT in DGtal::MultiPhaseField2<TLabelImage, TFieldImage, TEvolver>::getSignedDistance" ); 
	  else
      {
	      //dist = std::sqrt( (double) rDtImage( p ) ) - 0.5;  
	      dist = rDtImage( p ) - 0.5;  
      }
	}
      else
	{
	  //dist = - ( std::sqrt( (double) dtImage( p ) ) - 0.5 );  
	  dist = - ( dtImage( p ) - 0.5 );  
	}
      aImage.setValue(p, dist); /// \todo Periodicity !!!  
    }
}


/**
 * Return the number of phases
 */
template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
size_t
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getNumPhase() const
{
  return myLabels.size();
}

/**
 * Return one of the phase fields
 */
template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
typename DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >::FieldImage 
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getPhase( size_t i ) const
{
  return FieldImage(myFields[i]);
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> > const& object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/* GNU coding style */
/* vim: set ts=2 sw=2 expandtab cindent cinoptions=>4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1 : */


