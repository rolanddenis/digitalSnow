/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file MultiPhaseField2.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 * @author Roland Denis (\c roland.denis@univ-smb.fr )
 * LAboratory of MAthematics - LAMA (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2015/04/28
 *
 * @brief Implementation of inline methods defined in MultiPhaseField2.h
 *
 * This file is part of the DGtal library.
 */

#include <vector>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <cmath>

#include <Eigen/SVD>

#include <DGtal/images/SimpleThresholdForegroundPredicate.h>
#include "InlineTrace.h"

#ifdef _OPENMP
  #include <omp.h>
#endif

#include <thread>
#include <DGtal/math/RealFFT.h>
//#include "RealFFT.h"


//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::MultiPhaseField2(LabelImage& aI, typename TFieldImage::Value epsilon, bool calcDistance )
  : myLabelImage( aI ),
    myFields{ myLabelImage.domain(), TApproximation{1e-8} },
    myEpsilon{ epsilon }
{

  // Domain
  Domain domain = myFields.domain();

  // Retrieve labels
  std::set<Label> labels;
  for ( auto const& label : myLabelImage )
    labels.insert( label );

  // Store labels
  myLabels.insert(myLabels.end(), labels.cbegin(), labels.cend() );
  // TODO: check number of label

  // Initialize phase fields
  if ( calcDistance )
    {
      // For each label, build the corresponding phase field
      for ( std::size_t i = 1; i < myLabels.size(); ++i )
        {
          std::ostringstream dummy{};
          dummy << "Label " << myLabels[i];
          itrace.beginBlock( dummy.str() );

          /// new phase field
          FieldImage image(domain);

          /// DT computation
          getSignedDistance( myLabels[i], image );

          // Profile computation
          Profile profile( myEpsilon );  //TODO get epsilon from myEvolver or even better its profile function
          std::transform(image.begin(), image.end(), myFields[i].begin(), profile);

          itrace.endBlock();
        }

      // Build the air field (#0)
      // NB : maybe better if we rescale all fields ?
      itrace.beginBlock("Label 0");
      for ( auto const& point : domain )
        {
          typename TFieldImage::Value sum = 0;
          for ( auto v : myFields(point) )  sum += v.second;
          myFields.setValue( point, 0, 1 - sum );
        }
      itrace.endBlock();
    }
  else
    {
      // Simply set 1 where a label is present.
      itrace.beginBlock("Init phases");
      for ( auto const& point : domain )
        {
          size_t i = 0;
          for ( auto const label = myLabelImage(point); i < myLabels.size() && myLabels[i] != label; ++i) {}
          myFields.setValue( point, i, 1 );
        }
      itrace.endBlock();
     }

  // Calculating initial volume
  itrace.beginBlock("Initial volumes");
  myInitVolume.resize(myLabels.size(), 0);
  /*
  for ( auto const& point : domain )
    {
      for ( auto v : myFields(point) )
        myInitVolume[v.first] += v.second;
    }
  */
  std::fill( myInitVolume.begin(), myInitVolume.end(), static_cast<Value>(domain.size()) / myLabels.size() );

  itrace.endBlock();

  // Initialize FFTW <- has nothing to do here ... just for dev
  if ( fftw_init_threads() == 0 ) std::cout << "!!! Parallel FFTW initialization failed !!!" << std::endl;
  fftw_plan_with_nthreads( std::thread::hardware_concurrency() );
  //fftw_plan_with_nthreads(2);

  trace.beginBlock("Statistics");
  trace.info() << myFields.getInfos() << std::endl;
  trace.endBlock();
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::~MultiPhaseField2()
{
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
double
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::update(const double& aT)
{
  using std::size_t;
  using Point = typename TFieldImage::Point;
  using real = typename TFieldImage::Value;

  const real alpha = 1;
  Domain domain = myFields.domain();

  /////////////////////////////////////////////////////////////////////////////
  // Diffusion
  trace.beginBlock("Diffusion");
  using FFT  =  DGtal::RealFFT<Domain, real>;
  for ( size_t i = 0; i < myLabels.size(); ++i )
    {
      itrace.beginBlock("Diffusion");

      itrace.beginStep("Read");
      //auto bb_field = myFields.getBBImage(i, Point::diagonal(10)); // Bounding box & periodicity ?!!!
      auto bb_field = myFields[i];

      //FFT fft(bb_field.domain());
      FFT fft( bb_field.domain(), RealPoint::zero, myRealExtent );

      //auto spatial_data = fft.getSpatialStorage();

      // Copy
      auto spatial_image = fft.getSpatialImage();
      std::copy( bb_field.cbegin(), bb_field.cend(), spatial_image.begin() );

      //auto const eps = myEpsilon;
      //std::transform( bb_field.cbegin(), bb_field.cend(), spatial_image.begin(),
      //                [alpha, eps] ( real v ) { return ( v * (v-1) * (2*v-1) - alpha*v ) / std::pow(eps, 2); } );


      // Forward transformation
      itrace.beginStep("fftw");
      fft.forwardFFT(FFTW_MEASURE);

      itrace.beginStep("Conv");

      auto const extent = fft.getSpatialExtent();
      auto freq_image = fft.getFreqImage();

      auto const freq_domain = fft.getFreqDomain();

#ifdef _OPENMP
      const size_t N_thread = omp_get_max_threads();
#else
      const size_t N_thread = 1;
#endif

      #pragma omp parallel
      #pragma omp single nowait
      for ( size_t pos = 0; pos < N_thread; ++pos )
        {
          auto const dim = TFieldImage::dimension;
          auto pt_begin = freq_domain.lowerBound();
          auto pt_end = freq_domain.upperBound();
          pt_end[dim-1]   = pt_begin[dim-1] + ((pos+1)*extent[dim-1])/N_thread - 1;
          pt_begin[dim-1] = pt_begin[dim-1] + (pos*extent[dim-1])/N_thread;

          Domain curr_domain { pt_begin, pt_end };
          auto curr_freq_image = decltype(freq_image)(freq_image, curr_domain ); // Not very clean ...

          #pragma omp task firstprivate(curr_freq_image)
          for ( auto it = curr_freq_image.begin(), it_end = curr_freq_image.end() ; it != it_end ; ++it )
            {
              const auto pt = fft.calcScaledFreqCoords( it.getPoint() );
              const auto norm2 = pt.dot( pt );

              const double c = std::exp( -4*M_PI*M_PI*aT*norm2 );
              //const double c = 1. / ( 4*M_PI*M_PI*norm2 + alpha/(myEpsilon*myEpsilon) );
              *it *= c;
            }

        }

      // Back in spatial space
      itrace.beginStep("ifftw");
      fft.backwardFFT(FFTW_MEASURE, false);

      // Store the result
      itrace.beginStep("Write");
      const size_t n = fft.getSpatialDomain().size();
      //std::transform( spatial_image.cbegin(), spatial_image.cend(), bb_field.begin(), [n] (real v) { return v/n; } );

      // Reaction while saving result
      const real dummy = aT / (myEpsilon * myEpsilon);
      std::transform( spatial_image.cbegin(), spatial_image.cend(),
                      bb_field.begin(),
                      [n, dummy] (real v)
                        {
                          const real u = v/n;
                          return u - dummy * u * (u-1.) * (2*u-1.);
                        }
      );

      itrace.endBlock();
    }
  trace.endBlock();
  // End diffusion


  /*
  /////////////////////////////////////////////////////////////////////////////
  // Reaction
  itrace.beginBlock("Reaction");
  const real dummy = aT / (myEpsilon * myEpsilon);
  for ( auto const& point : domain )
    {
      const size_t id = myFields.linearized(point);
      // Need for a mutable iterator over values ...
      for ( size_t i = 0; i < myLabels.size(); ++i )
        {
          const real u = myFields.getValueByIndex(id, i);
          if ( u != 0 )
            {
              myFields.setValue(point, i, u - dummy * u * (u-1) * (2*u-1), id);
            }
        }
    }
  itrace.endBlock();
  */

  /////////////////////////////////////////////////////////////////////////////
  // Projection
  itrace.beginBlock("Lagrangian");

  itrace.beginStep("linear_system");
  const size_t phase_cnt = myInitVolume.size();

  // Rmq: MatrixXd is column-major but since his size is relatively small, we will do like it was row-major.
  using namespace Eigen;
  MatrixXd M( phase_cnt, phase_cnt );
  VectorXd b( phase_cnt );
  VectorXd int_u( phase_cnt );
  VectorXd int_sqrt2Wu( phase_cnt );

  // Pre-calculating $\int u_i$ and $\int \sqrt{2W(u_i)}$.
  int_u.fill(0);
  int_sqrt2Wu.fill(0);
  for ( auto const & point : domain )
    {
      for ( auto const& vi : myFields(point) )
        {
          const auto  i = vi.first;
          const auto ui = vi.second;

          int_u(i) += ui;
          int_sqrt2Wu(i) += std::abs( ui * (1-ui) );
       }
    }


  M.fill(0);
  b.fill(0);

  for ( auto const& point : domain )
    {
      const size_t id = myFields.linearized(point);

      real sum_sqrt2Wu = 0;
      real sum_u = 0;
      real temp  = 0;

      for ( auto const& vi : myFields(point) )
        {
          const auto  i = vi.first;
          const real ui = vi.second;

          sum_u += ui;
          const real sqrt2Wui = std::abs( ui * (1-ui) );

          sum_sqrt2Wu += sqrt2Wui;
          if ( sqrt2Wui != 0 )
            temp += ( myInitVolume[i] - int_u(i) ) * sqrt2Wui / int_sqrt2Wu(i);
        }
      temp = 1 - sum_u - temp;

      for ( auto const& vi : myFields(point) )
        {
          const auto  i = vi.first;
          const real ui = vi.second;

          const real sqrt2Wui = std::abs( ui * (1-ui) );

          if ( sqrt2Wui != 0 )
            {
              for ( auto const& vj : myFields(point) )
                {
                  const auto  j = vj.first;
                  const real uj = vj.second;

                  const real sqrt2Wuj = std::abs( uj * (1-uj) );

                  M(i, j) -= sqrt2Wui * sqrt2Wuj / ( int_sqrt2Wu(i) * sum_sqrt2Wu );
                }

              b(i) += temp * sqrt2Wui / sum_sqrt2Wu;
            }
        }
    }

  for ( std::size_t i = 0; i < phase_cnt; ++i )
    {
      M( i, i ) += 1.;
      M( phase_cnt-1, i ) = 1.;
    }
  b( phase_cnt-1 ) = 0.;

  itrace.endStep();

  itrace.beginStep("solve");
  VectorXd int_lambda = M.colPivHouseholderQr().solve(b);
  itrace.endStep();

  itrace.beginStep("mu, lambda & update");

  // Calculation of mu_i
  VectorXd mu( phase_cnt );
  for ( std::size_t i = 0; i < phase_cnt; ++i )
    mu( i ) = int_sqrt2Wu(i) != 0 ? ( myInitVolume[i] - int_u(i) - int_lambda(i) ) / int_sqrt2Wu(i) : 0;

  for ( auto const& point : domain )
    {
      real sum_sqrtWu = 0;
      real lambda = 0;

      for ( auto value : myFields(point) )
        {
          const auto  i = value.first;
          const real ui = value.second;

          const real sqrtWui = std::abs( ui * (1 - ui) );

          sum_sqrtWu += sqrtWui;
          lambda += ui + mu(i) * sqrtWui;
        }
      lambda = sum_sqrtWu != 0 ? ( 1 - lambda ) / sum_sqrtWu : 0;

      const size_t id = myFields.linearized(point);
      for ( size_t i = 0; i < myLabels.size(); ++i )
        {
          const real u = myFields.getValueByIndex(id, i);
          const real v = u + ( lambda + mu[i] ) * std::abs(u * (1-u));
          myFields.setValue(point, i, v, id);
        }
    }
  itrace.endStep();
  itrace.endBlock();

  return aT;
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::updateDomainSize()
{
  using std::size_t;
  using Point = typename TFieldImage::Point;
  using real = typename TFieldImage::Value;

  std::vector<real> gradient( Point::dimension, 0 );

  Domain domain = myFields.domain();

  trace.beginBlock("Domain optimization");
  using FFT  =  DGtal::RealFFT<Domain, real>;
  for ( size_t i = 0; i < myLabels.size(); ++i )
    {
      itrace.beginBlock("Diffusion");

      itrace.beginStep("Read");
      auto bb_field = myFields[i];
      FFT fft( bb_field.domain(), RealPoint::zero, RealPoint::diagonal(1.) );

      auto spatial_image = fft.getSpatialImage();
      std::copy( bb_field.cbegin(), bb_field.cend(), spatial_image.begin() );

      itrace.beginStep("fftw");
      fft.forwardFFT( FFTW_MEASURE );

      itrace.beginStep("gradient");
      const auto curr_freq_image = fft.getFreqImage();
      for ( auto const& pt : fft.getSpatialDomain() )
        {
          const auto scaled_pt = fft.calcScaledFreqCoords( pt );
          bool dummy;
          const auto freq_pt   = fft.calcNativeFreqCoords( scaled_pt, dummy );
          const auto value = curr_freq_image(freq_pt);
          for ( typename Point::Dimension j = 0; j < Point::dimension; ++j )
            gradient[j] += std::norm( value * static_cast<real>(scaled_pt[j]) );
       }

      itrace.endBlock();
    }

  real prod_L = 1.;
  for ( auto & g : gradient )
    prod_L *= g;
  prod_L = std::pow( prod_L, 1. / Point::dimension );

  real prod_Extent = 1.;
  for ( typename Point::Dimension i = 0; i < Point::dimension - 1; ++i )
    {
      myRealExtent[ i ] = std::min( std::max( std::sqrt( gradient[i]/prod_L ), 0.1 ), 10. );
      prod_Extent *= myRealExtent[ i ];
    }
  myRealExtent[ Point::dimension-1 ] = 1. / prod_Extent;

  trace.endBlock();
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
std::size_t
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::updateLabels()
{
  /// update image of labels
  trace.beginBlock("Updating Label");
  size_t diff_cnt = 0;
  for ( auto const& point : myFields.domain() )
    {
      const size_t id = myFields.linearized(point);
      Label max_label;
      Value max_value = 0;
      for ( std::size_t i = 0; i < myLabels.size(); ++i )
        {
          Value value = myFields.getValueByIndex(id, i);
          if (value >= max_value)
            {
              max_value = value;
              max_label = myLabels[i];
            }
        }

      if ( myLabelImage(point) != max_label ) ++diff_cnt;
      myLabelImage.setValue( point, max_label );
    }
  trace.info() << "Movement on " << diff_cnt << " cells (" << std::fixed << std::setprecision(5) << (100.0*diff_cnt)/myFields.domain().size() << "%)" << std::endl;
  trace.endBlock();

  return diff_cnt;
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::dispInfos() const
{
  itrace.beginBlock("Statistics");

  itrace.beginStep("LabelledMap");
  const auto fields_info = myFields.getInfos();

  itrace.beginStep("Perimeters");
  const auto perimeters = getPerimeters();
  itrace.endBlock();

  std::cout << fields_info << std::endl;

  std::cout << std::setprecision(5);

  for ( std::size_t i = 0; i < perimeters.size(); ++i )
    std::cout << "P" << i << "=" << perimeters[i] << " ";
  std::cout << std::endl;

  // Morgan'cost
  Value perimeter_sum = 0;
  for ( auto value : perimeters ) perimeter_sum += value;
  perimeter_sum /= 2 * std::pow( myFields.domain().size(), static_cast<double>(Domain::dimension-1)/Domain::dimension ) ;
  const Value morgan_cost = perimeter_sum / std::pow( perimeters.size(), 1./3. );
  std::cout << "Morgan's cost = " << morgan_cost << std::endl;
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::selfDisplay ( std::ostream & out ) const
{
  out << "[MultiPhaseField2] ";
  out << myFields.size() << " regions ";
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
bool
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::isValid() const
{
  return true;
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getSignedDistance(const Label& aLabel, FieldImage& aImage) const
{

  Domain d = Domain( myLabelImage.domain().lowerBound(), myLabelImage.domain().upperBound() );
  typename Domain::ConstIterator cIt = d.begin();
  typename Domain::ConstIterator cItBegin = d.begin();
  typename Domain::ConstIterator cItEnd = d.end();

  //temporary buffers
  typedef ImageContainerBySTLVector<Domain, DGtal::int32_t> Image;
  Image copy1( d );
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    {
      if ( myLabelImage( *cIt ) == aLabel )
	copy1.setValue( *cIt, 0 );
      else
	copy1.setValue( *cIt, 1 );
    }
  Image copy2( d );
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    {
      if ( myLabelImage( *cIt ) != aLabel )
	copy2.setValue( *cIt, 0 );
      else
	copy2.setValue( *cIt, 1 );
    }

  // Distance transformation
  // Old code was:
  //    typedef  DistanceTransformation<Image, 2> DT;
  //    DT dt;
  //    typename DT::OutputImage dtImage = dt.compute ( copy1 );
  //    typename DT::OutputImage rDtImage = dt.compute ( copy2 );
  //
  // I suppose that 2 means L2Metric (with the correct Z#i-namespace in scope),
  //    and that 0 value is used as threshold for the predicate.
  typedef typename DGtal::functors::SimpleThresholdForegroundPredicate<Image> PointPredicate;
  typedef typename DGtal::DistanceTransformation<Space, PointPredicate, L2Metric> DT;

  PointPredicate copy1Predicate( copy1, 0 );
  PointPredicate copy2Predicate( copy2, 0 );

  DT  dtImage( copy1.domain(), copy1Predicate, l2Metric );
  DT rDtImage( copy2.domain(), copy2Predicate, l2Metric );

  //deduce the signed distance function
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    { //for each domain point

      Point p( *cIt ); //point p
      double dist = 0; //signed distance
      if ( dtImage( p ) == 0 )
        {
          if ( rDtImage( p ) == 0 )
            ASSERT( false && "Err init with DT in DGtal::MultiPhaseField2<TLabelImage, TFieldImage, TEvolver>::getSignedDistance" );
          else
            {
              //dist = std::sqrt( (double) rDtImage( p ) ) - 0.5;
              dist = rDtImage( p ) - 0.5;
            }
        }
      else
        {
          //dist = - ( std::sqrt( (double) dtImage( p ) ) - 0.5 );
          dist = - ( dtImage( p ) - 0.5 );
        }
      aImage.setValue(p, dist); /// \todo Periodicity !!!
    }
}


/**
 * Return the number of phases
 */
template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
size_t
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getNumPhase() const
{
  return myLabels.size();
}

/**
 * Return one of the phase fields
 */
template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
typename DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >::FieldImage
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getPhase( size_t i ) const
{
  return FieldImage(myFields[i]);
}

/**
 * Return the perimeter of each phase.
 */
template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
std::vector<typename TFieldImage::Value>
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getPerimeters() const
{
  std::vector<Value> perimeters( getNumPhase(), 0 );
  std::vector<Value> tmp( getNumPhase() );

  auto const& domain = myFields.domain();
  for ( auto const& point : domain )
    {
      for ( std::size_t d = 0; d < Domain::dimension; ++d )
        {
          std::fill( tmp.begin(), tmp.end(), 0 );

          for ( typename Point::Coordinate pos = -1; pos <= 1; pos += 2 )
            {
              auto curr_point = point + Point::base(d, pos);
              if ( ! domain.isInside(curr_point) )
                curr_point[d] -= pos*( domain.upperBound()[d] - domain.lowerBound()[d] + 1 );

              for ( auto value : myFields(curr_point) )
                {
                  tmp[value.first] += pos*value.second;
                }
            }

          for ( std::size_t i = 0; i < getNumPhase(); ++i )
            perimeters[i] += 0.5 * myEpsilon * std::pow( 0.5 * tmp[i], 2 );
        }

      for ( auto value : myFields(point) )
        perimeters[value.first] += 0.5 * std::pow(value.second, 2) * std::pow(1-value.second, 2) / myEpsilon;

    }

  // Coefficient in the gamma-convergence of the Ginzburg-Landau energy to the perimeter.
  for ( auto& value : perimeters )
    value *= 6;

  return perimeters;
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
      DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> > const& object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/* GNU coding style */
/* vim: set ts=2 sw=2 expandtab cindent cinoptions=>4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1 : */


