/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file MultiPhaseField2.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 * @author Roland Denis (\c roland.denis@univ-smb.fr )
 * LAboratory of MAthematics - LAMA (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2015/04/28
 *
 * @brief Implementation of inline methods defined in MultiPhaseField2.h
 *
 * This file is part of the DGtal library.
 */

#include <vector>
#include <sstream>
#include <iostream>
#include <algorithm>

#include <Eigen/SVD>

#include <DGtal/images/SimpleThresholdForegroundPredicate.h>
#include "InlineTrace.h"

#include <omp.h>
#include <thread>
#include "RealFFT.h"


//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::MultiPhaseField2(LabelImage& aI, typename TFieldImage::Value epsilon, bool calcDistance )
  : myLabelImage( aI ),
    myFields{ myLabelImage.domain(), TApproximation{1e-8} },
    myEpsilon{ epsilon }
{ 
 
  // Domain
  Domain domain = myFields.domain();

  // Retrieve labels
  std::set<Label> labels;
  for ( auto const& label : myLabelImage )
    labels.insert( label );

  // Store labels
  myLabels.insert(myLabels.end(), labels.cbegin(), labels.cend() );

  // Initialize phase fields
  if ( calcDistance )
    {
      // For each label, build the corresponding phase field
      for ( std::size_t i = 1; i < myLabels.size(); ++i )
        {
          std::ostringstream dummy{};
          dummy << "Label " << myLabels[i];
          itrace.beginBlock( dummy.str() );

          /// new phase field
          FieldImage image(domain); 

          /// DT computation
          getSignedDistance( myLabels[i], image );

          // Profile computation
          Profile profile( myEpsilon );  //TODO get epsilon from myEvolver or even better its profile function
          std::transform(image.begin(), image.end(), myFields[i].begin(), profile);       

          itrace.endBlock();
        }

      // Build the air field (#0)
      // NB : maybe better if we rescale all fields ?
      itrace.beginBlock("Label 0");
      for ( auto const& point : domain )
        {
          typename TFieldImage::Value sum = 0;
          for ( auto v : myFields(point) )  sum += v.second;
          myFields.setValue( point, 0, 1 - sum );
        }
      itrace.endBlock();
    }
  else
    {
      // Simply set 1 where a label is present.
      itrace.beginBlock("Init phases");
      for ( auto const& point : domain )
        {
          size_t i = 0;
          for ( auto const label = myLabelImage(point); i < myLabels.size() && myLabels[i] != label; ++i) {}
          myFields.setValue( point, i, 1 );
        }
      itrace.endBlock();
     }

  // Calculating initial volume
  itrace.beginBlock("Initial volumes");
  myInitVolume.resize(myLabels.size(), 0);
  for ( auto const& point : domain )
    {
      for ( auto v : myFields(point) )
        myInitVolume[v.first] += v.second;
    }
  itrace.endBlock();

  // Initialize FFTW <- has nothing to do here ... just for dev
  if ( fftw_init_threads() == 0 ) std::cout << "!!! Parallel FFTW initialization failed !!!" << std::endl;
  fftw_plan_with_nthreads( std::thread::hardware_concurrency() );

  trace.beginBlock("Statistics");
  trace.info() << myFields.getInfos() << std::endl;
  trace.endBlock();
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::~MultiPhaseField2()
{ 
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
double
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::update(const double& aT)
{
  using std::size_t; 
  using Point = typename TFieldImage::Point;
  using real = typename TFieldImage::Value;

  Domain domain = myFields.domain();

  // Diffusion
  trace.beginBlock("Diffusion");
  using FFT  =  RealFFT<Domain, real>;
  for ( size_t i = 0; i < myLabels.size(); ++i )
    {
      itrace.beginBlock("Diffusion");

      itrace.beginStep("Read");
      //auto bb_field = myFields.getBBImage(i, Point::diagonal(10)); // Bounding box & periodicity ?!!!
      auto bb_field = myFields[i];

      FFT fft(bb_field.domain());
      auto spatial_data = fft.getSpatialStorage();

      // Copy
      auto spatial_image = fft.getSpatialImage();
      std::copy( bb_field.cbegin(), bb_field.cend(), spatial_image.begin() );  


      // Forward transformation
      itrace.beginStep("fftw");
      fft.forwardFFT(FFTW_MEASURE);

      itrace.beginStep("Conv");
     
      auto const extent = fft.getSpatialExtent();
      auto freq_image = fft.getFreqImage();
      
      auto const freq_domain = fft.getFreqDomain();
      const size_t N_thread = omp_get_max_threads();
      #pragma omp parallel 
      #pragma omp single nowait
      for ( size_t pos = 0; pos < N_thread; ++pos )
        {
          auto const dim = TFieldImage::dimension;
          auto pt_begin = freq_domain.lowerBound();
          auto pt_end = freq_domain.upperBound();
          pt_end[dim-1]   = pt_begin[dim-1] + ((pos+1)*extent[dim-1])/N_thread - 1;
          pt_begin[dim-1] = pt_begin[dim-1] + (pos*extent[dim-1])/N_thread;

          Domain curr_domain { pt_begin, pt_end };
          auto curr_freq_image = decltype(freq_image)(freq_image, curr_domain ); // Not very clean ...

          #pragma omp task firstprivate(curr_freq_image)
          for ( auto it = curr_freq_image.begin(), it_end = curr_freq_image.end() ; it != it_end ; ++it )
            {
              const auto point = it.getPoint();
              double norm2 = 0;
              for ( size_t j = 0; j < TFieldImage::dimension; ++j)
                {
                  double coord = static_cast<double>(point[j]) / extent[j];
                  if ( coord >= 0.5 ) coord -= 1.;
                  norm2 += coord*coord;
                }
              const double c = std::exp( -4*M_PI*M_PI*aT*norm2 );

              // New value

              auto const v = *it;
              *it = { c*std::real(v), c*std::imag(v) };
            }

        }

      // Back in spatial space
      itrace.beginStep("ifftw");
      fft.backwardFFT(FFTW_MEASURE);

      // Store the result
      itrace.beginStep("Write");
      const size_t n = fft.getSpatialDomain().size();
      std::transform( spatial_image.cbegin(), spatial_image.cend(), bb_field.begin(), [n] (real v) { return v/n; } );

      itrace.endBlock();
    }
  trace.endBlock();
  // End diffusion

  bool reaction1 = false;
  if (reaction1) {
  // Phase overlap
  trace.beginBlock("Phase overlap");
  TFieldImage phase_overlap(domain);
  for ( auto const& point : domain )
    {
      real sum = 0;
      for ( auto const& value : myFields(point) )
        sum += value.second;
      phase_overlap.setValue(point, 1 - sum);
    }
  trace.endBlock();
  // End phase overlap
  
  // Volume loss estimation
  // \warning : we suppose that labels in LabelledMap are consecutive.
  trace.beginBlock("Volume loss estimation");
  std::vector<real> num( myLabels.size(), 0 );
  std::vector<real> denum( myLabels.size(), 0 );
  for ( auto const& point : domain )
    {
      for ( auto value : myFields(point) )
        {
          const real u = value.second;
          num[value.first]   += u * (u - 1) * (2*u - 1);
          denum[value.first] += std::abs(u) * std::abs(1 - u);
        }
    }
  
  std::vector<real> volume_loss( num.size() );
  for ( size_t i = 0; i < volume_loss.size(); ++i )
    volume_loss[i] = num[i] / denum[i];

  trace.endBlock();
  // End volume loss estimation
  
  // Lagrangian multiplier
  trace.beginBlock("Lagrange multiplier");
  for ( auto const& point : domain )
    {
      real sum = 0;
      for ( auto value : myFields(point) )
        {
          const real u = value.second;
          //sum += u*(u-1) * ( (2*u-1) + volume_loss[value.first] );
          sum += u*(u-1) * (2*u-1) -  volume_loss[value.first] * std::abs(u) * std::abs(1-u);
        }
      phase_overlap.setValue(point, ( sum + phase_overlap(point) ) / myLabels.size() );
      //phase_overlap.setValue(point, ( sum + phase_overlap(point) ) / myFields(point).size() );
    }
  trace.endBlock();
  // End Lagrangian multiplier

  // Evolution - Method A
  trace.beginBlock("Evolution");
  const real dummy = aT / (myEpsilon * myEpsilon);
  for ( auto const& point : domain )
    {
      size_t id = myFields.linearized(point); // Hum ...

      for ( size_t i = 0; i < myLabels.size(); ++i )
        {
          const real u = myFields.getValueByIndex(id, i);
          const real p = (u == 0) ? 0 : u*(u-1) * ( (2*u-1) + volume_loss[i] );
          //const real p = (u == 0) ? 0 : ( u*(u-1) *(2*u-1) - volume_loss[i]*std::abs(u*(1-u)) );
          const real v = u - dummy * (p - phase_overlap(point));
          myFields.setValue(point, i, v, id);
        }
    }
  trace.endBlock();
  // End evolution - Method A
  } // end block

  // Reaction
  if (!reaction1)
    {
      itrace.beginBlock("Reaction");
      const real dummy = aT / (myEpsilon * myEpsilon);
      for ( auto const& point : domain )
        {
          const size_t id = myFields.linearized(point);
          // Need for a mutable iterator over values ...
          for ( size_t i = 0; i < myLabels.size(); ++i )
            {
              const real u = myFields.getValueByIndex(id, i);
              if ( u != 0 )
                {
                  myFields.setValue(point, i, u - dummy * u * (u-1) * (2*u-1), id);
                }
            }
        }
      itrace.endBlock();

      itrace.beginBlock("Lagrangian");
      auto phi = [](real u) { return u; };

      itrace.beginStep("linear_system");
      const size_t phase_cnt = myInitVolume.size();
      // Rmq: MatrixXd is column-major but since his size is relatively small, we will do like it was row-major.
      using namespace Eigen;
      MatrixXd M( phase_cnt, phase_cnt );
      VectorXd b( phase_cnt );
      M.fill(0);

      for ( size_t i = 0; i < phase_cnt; ++i )
        b(i) = myInitVolume[i];

      for ( auto const& point : domain )
        {
          const size_t id = myFields.linearized(point);
          
          real sum_u = 0;
          real sum_phiu = 0;
          for ( auto const v : myFields(point) )
            {
              sum_u += v.second;
              sum_phiu += phi(v.second);
            }
          
          for ( auto const& vi : myFields(point) )
            {
              const real ui = vi.second;
              const real phi_ui = phi(ui);
              const real weighted_phiu = phi_ui / sum_phiu;

              M(vi.first,vi.first)  += std::abs( ui * (1-ui) );
              b(vi.first)    += -ui + weighted_phiu * ( sum_u - 1 );
              for ( auto const& vj : myFields(point) )
                {
                  const real uj = vj.second;
                  M(vi.first,vj.first) -= weighted_phiu * std::abs( uj * (1-uj) );
                }
            }
        }
      itrace.endStep();

      itrace.beginStep("svd");
      JacobiSVD<MatrixXd> svd(M, ComputeFullU | ComputeFullV);
      auto s = svd.singularValues();
      for ( size_t i = 0; i < phase_cnt-1; ++i )
        s[i] = 1 / s[i];
      M = svd.matrixV() * s.asDiagonal() * svd.matrixU().transpose();
      VectorXd mu = M * b;
      itrace.endStep();

      itrace.beginStep("lambda & update");
      for ( auto const& point : domain )
        {

          real sum_phiu = 0;
          real lambda = 0;
          for ( auto value : myFields(point) )
            {
              const real u = value.second;
              sum_phiu += phi(u);
              lambda += u + mu[value.first] * std::abs(u * (1-u));
            }
          lambda = - (lambda - 1) / sum_phiu;

          const size_t id = myFields.linearized(point);
          for ( size_t i = 0; i < myLabels.size(); ++i )
            {
              const real u = myFields.getValueByIndex(id, i);
              const real v = u + mu[i]*std::abs(u * (1-u)) + lambda*phi(u);
              myFields.setValue(point, i, v, id);
            }
        }
      itrace.endStep();
    }
  itrace.endBlock();


  
  /// update image of labels
  {
    trace.beginBlock("Updating Label");
    for ( auto const& point : domain )
      {
        const size_t id = myFields.linearized(point);
        Label max_label;
        real max_value = 0;
        for ( std::size_t i = 0; i < myLabels.size(); ++i )
          {
            real value = myFields.getValueByIndex(id, i);
            if (value >= max_value)
              {
                max_value = value;
                max_label = myLabels[i];
              }
          }

        myLabelImage.setValue( point, max_label );
      }
    trace.endBlock();
  }

  trace.beginBlock("Statistics");
  trace.info() << myFields.getInfos() << std::endl;
  trace.endBlock();

  return aT; 
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::selfDisplay ( std::ostream & out ) const
{
  out << "[MultiPhaseField2] ";
  out << myFields.size() << " regions "; 
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
bool
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::isValid() const
{
  return true;
}

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
void
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getSignedDistance(const Label& aLabel, FieldImage& aImage) const
{

  Domain d = Domain( myLabelImage.domain().lowerBound(), myLabelImage.domain().upperBound() );
  typename Domain::ConstIterator cIt = d.begin(); 
  typename Domain::ConstIterator cItBegin = d.begin(); 
  typename Domain::ConstIterator cItEnd = d.end(); 

  //temporary buffers
  typedef ImageContainerBySTLVector<Domain, DGtal::int32_t> Image; 
  Image copy1( d );
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    { 
      if ( myLabelImage( *cIt ) == aLabel )
	copy1.setValue( *cIt, 0 ); 
      else
	copy1.setValue( *cIt, 1 ); 
    }
  Image copy2( d );  
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    { 
      if ( myLabelImage( *cIt ) != aLabel )
	copy2.setValue( *cIt, 0 ); 
      else
	copy2.setValue( *cIt, 1 ); 
    }

  // Distance transformation
  // Old code was:
  //    typedef  DistanceTransformation<Image, 2> DT;
  //    DT dt;
  //    typename DT::OutputImage dtImage = dt.compute ( copy1 );
  //    typename DT::OutputImage rDtImage = dt.compute ( copy2 );
  // 
  // I suppose that 2 means L2Metric (with the correct Z#i-namespace in scope),
  //    and that 0 value is used as threshold for the predicate.
  typedef typename DGtal::functors::SimpleThresholdForegroundPredicate<Image> PointPredicate;
  typedef typename DGtal::DistanceTransformation<Space, PointPredicate, L2Metric> DT;
    
  PointPredicate copy1Predicate( copy1, 0 );
  PointPredicate copy2Predicate( copy2, 0 );

  DT  dtImage( copy1.domain(), copy1Predicate, l2Metric );
  DT rDtImage( copy2.domain(), copy2Predicate, l2Metric );
  
  //deduce the signed distance function 
  for (cIt = cItBegin; cIt != cItEnd; ++cIt)
    { //for each domain point

      Point p( *cIt ); //point p
      double dist = 0; //signed distance
      if ( dtImage( p ) == 0 )
	{
	  if ( rDtImage( p ) == 0 )
	    ASSERT( false && "Err init with DT in DGtal::MultiPhaseField2<TLabelImage, TFieldImage, TEvolver>::getSignedDistance" ); 
	  else
      {
	      //dist = std::sqrt( (double) rDtImage( p ) ) - 0.5;  
	      dist = rDtImage( p ) - 0.5;  
      }
	}
      else
	{
	  //dist = - ( std::sqrt( (double) dtImage( p ) ) - 0.5 );  
	  dist = - ( dtImage( p ) - 0.5 );  
	}
      aImage.setValue(p, dist); /// \todo Periodicity !!!  
    }
}


/**
 * Return the number of phases
 */
template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
size_t
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getNumPhase() const
{
  return myLabels.size();
}

/**
 * Return one of the phase fields
 */
template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
typename DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >::FieldImage 
DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> >
::getPhase( size_t i ) const
{
  return FieldImage(myFields[i]);
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <
  typename TLabelImage,
  typename TFieldImage,
  typename TDomain, typename TContainer, typename TApproximation, typename TBoundingBox
>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    DGtal::MultiPhaseField2< TLabelImage, TFieldImage, DGtal::ApproximatedMultiImage<TDomain, TContainer, TApproximation, TBoundingBox> > const& object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/* GNU coding style */
/* vim: set ts=2 sw=2 expandtab cindent cinoptions=>4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1 : */


